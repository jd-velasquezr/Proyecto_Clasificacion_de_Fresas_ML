# -*- coding: utf-8 -*-
"""CodigoRaspberryFinal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JKVCCKo6vaQaBHP3lp7rjkfCNKBo4oB_
"""

"""
TESIS DE GRADO: Detección de una enfermedad en el fruto de la fresa en su etapa post-cultivo utilizando Inteligencia Artificial.
CÓDIGO IMPLEMENTADO EN LA RASPBERRY.
ELABORADO POR: JUAN DAVID VELÁSQUEZ RESTREPO Y DANIEL BARANDICA.
"""
# Importación de librerías necesarias para el funcionamiento del código.
import os
import numpy as np
import cv2 as cv
import pandas as pd
import warnings
warnings.filterwarnings('ignore')

from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import DistanceMetric
from sklearn import svm
from sklearn.metrics import classification_report, confusion_matrix 
from sklearn.neural_network import MLPClassifier
import time
import pickle
import glob
import re
import os
from tqdm import tqdm

# Esta sección realiza la extracción de características de las imágenes. Lo que
# corresponde la función extracción de características.

def extrac(img):
  chans = cv.split(img)
  colors = ("b", "g", "r")
  features = []

  # loop over the image channels
  for (chan, color) in zip(chans, colors):
    hist = cv.calcHist([chan], [0], None, [16], [0, 255])
    features.extend(hist)
      
  features = np.array(features).flatten()
  return features

# Esta sección efectúa el procesamiento de las imágenes aplicando el aumento de
# brillo, contraste de colores, filtrado de colores y adicionalmente el uso de 
# la máscara de las fresas.
def img_process(img):
  img = cv.resize(img, (256, 192), interpolation = cv.INTER_AREA)
  brightness = 100
  contrast = 150

  #Operaciones para aumentarte contraste y brillo de imagen
  img = np.int16(img)
  img = img * (contrast/255+1) - contrast + brightness
  img = np.clip(img, 0, 255)
  img = np.uint8(img)

  # SHARPENING para disminuir falta de nitidez
  kernel = np.array([[0, -1, 0],
                   [-1, 5,-1],
                   [0, -1, 0]])
  img = cv.filter2D(src=img, ddepth=-1, kernel=kernel)

  #CONVERSION A ESPACIO DE COLOR HSV
  frameHSV = cv.cvtColor(img, cv.COLOR_BGR2HSV)

  # FILTRO COLOR BLANCO
  lower_white = np.array([0,0,255-15])
  upper_white = np.array([255,15,255])
  maskww = cv.inRange(frameHSV, lower_white, upper_white)
  #SE REALIZA LA OPERACION MORFOLOGICA DE CLOSING, PARA ELIMINAR LOS HUECOS DE RUIDO
  #QUE PUEDAN EXISTER AL REALIZAR EL FILTRADO
  W = 5
  kernel = cv.getStructuringElement(cv.MORPH_RECT, (2 * W + 1, 2 * W + 1))
  mask_antiwhite = cv.morphologyEx(maskww, cv.MORPH_CLOSE, kernel)
  #SE NIEGA LA MASCARA, YA QUE NO DESEAMOS TOMAR EL COLOR VERDE (HOJAS DE LA FRESA), POR EL CONTRARIO,
  #QUEREMOS ELIMINAR LAS HOJAS DE LA FRESA
  #mask_antiwhite = cv.bitwise_not(mask_antiwhite)
  maskWhitevis = cv.bitwise_and(img, img, mask= mask_antiwhite)


  # FILTRO VERDE y AMARILLO
  lower_green = np.array([20,25, 25])
  upper_green = np.array([90, 255, 255])

  maskGY = cv.inRange(frameHSV, lower_green, upper_green)
  maskGY = cv.bitwise_not(maskGY)
  res = cv.bitwise_and(img, img, mask=maskGY)


  # FILTRADO COMPLETO DE COLOR
  #FILTRADO DE COLOR ROJO 
  redBajo1 = np.array([0, 100, 20], np.uint8)
  redAlto1 = np.array([10, 255, 255], np.uint8)
  redBajo2 = np.array([160, 100, 20], np.uint8)
  redAlto2 = np.array([179, 255, 255], np.uint8)

  maskRed1 = cv.inRange(frameHSV, redBajo1, redAlto1)
  maskRed2 = cv.inRange(frameHSV, redBajo2, redAlto2)
  maskRed = cv.add(maskRed1, maskRed2)

  W = 5
  kernel = cv.getStructuringElement(cv.MORPH_RECT, (2 * W + 1, 2 * W + 1))
  maskRed = cv.morphologyEx(maskRed, cv.MORPH_CLOSE, kernel)


  maskRedVis = cv.bitwise_and(img, img, mask= maskRed)

  maskFull = cv.add(maskRed, mask_antiwhite, maskGY)


  #EROSION PARA DISMINUIR O ELIMINAR EL GROSOR DE LAS LINEAS QUE SEAN MUY DELGADAS
  W = 1
  kernel = cv.getStructuringElement(cv.MORPH_RECT, (2 * W + 1, 2 * W + 1))
  maskFull = cv.erode(maskFull,kernel,iterations = 1)

  W = 15
  kernel = cv.getStructuringElement(cv.MORPH_RECT, (2 * W + 1, 2 * W + 1))
  maskFull = cv.morphologyEx(maskFull, cv.MORPH_CLOSE, kernel)
  maskFullVis = cv.bitwise_and(img, img, mask= maskFull)
  cv.imwrite(f'/home/user/Desktop/Dataset2/Processed/image_{i}',maskFullVis)

i = 0

# Se realiza la lectura de todos los archivos de imagen en formato .jpg del
# directorio en cuestión, donde se llama la función de procesamiento de imagen 
# el cual contiene la característica de guardar la imagen procesada en una 
# carpeta del mismo directorio para luego ser utilizada en la sección posterior.

contenido= os.listdir("/home/user/Desktop/Dataset2/")
r= re.compile("\.(jpg|png)", re.IGNORECASE)
coments= list(filter(r.search,contenido))
A= os.path.join("/home/user/Desktop/Dataset2/"+coments[0])
for i in tqdm(coments):
# Declaracion de path de imagenes
  path=os.path.join("/home/user/Desktop/Dataset2/"+i)
  img = cv.imread(path)
  img_process(img)
  
# Esta sección importa el archivo de escalizador de datos al igual que el 
# clasificador SVM a partir de los directorios en los cuales estos se encuentran.

scalerfile = '/home/user/Descargas/scaler.sav'
SVM = '/home/user/Descargas/SVM.sav'
scaler = pickle.load(open(scalerfile, 'rb'))
SVM = pickle.load(open(SVM, 'rb'))

# Luego de hacer el preprocesamiento, se leen las imagenes procesadas generadas
# y se llama la función de extracción de características, almacenando dichos 
# datos en un arreglo de tipo numpy.

file = []
data= np.zeros(shape=(1,48))
for img in glob.glob("/home/user/Desktop/Dataset2/Processed/*.jpg"):
  img_name = str(os.path.basename(img))
  file.append(img_name.replace("image_",""))
  #file.append(str(os.path.basename(img)))
  img = cv.imread(img)
  features = np.array(extrac(img))
  features= features.reshape(1,-1)
  data = np.append(data,features, axis = 0)
data= np.delete(data,0,0)

# Se escalizan los datos de las imágenes y se clasifica el estado de la fresa por
# cada una.
data = scaler.transform(data)
results = SVM.predict(data).T
file = np.array(file).T

# Se crea un dataframe que contiene el nombre del archivo al igual que su 
# respectiva etiqueta separada en dos columnas organizadas.

prediction_results = pd.DataFrame({'Imagen': file, 'Estado': results})
filepath = '/home/user/Descargas/pred_results.xlsx'    
prediction_results.to_excel(filepath)

# Se eliminan los archivos de las imágenes procesadas.

files = glob.glob("/home/user/Desktop/Dataset2/Processed/*")
for f in files:
    os.remove(f)